<!doctype html>
<html>
  <head>
    <title>Meekaa</title>

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
      body {
        display: block;
        margin: 0px;
        overflow: hidden;
        width: 100%;
        height: 100%;
      }
      #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        image-rendering: pixelated;
      }
      #input {
        position: absolute;
        bottom: 0%;
        left: 5%;
        width: 90%;
        height: 15%;
        image-rendering: pixelated;
        text-align: center;
        font-size: 30px; 
        color: white;
      }
    </style>
  </head>
  
  <body>
    <div id="input">
      
    </div>
    <canvas id="canvas"></canvas>
    <canvas id="buffer" style="display: none;"></canvas>
  </body>
  
  <script>
    const input = document.getElementById("input");

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext('2d');
    const buffer = document.getElementById('buffer');
    buffer.width = 32;
    buffer.height = 32;
    const bctx = buffer.getContext('2d');

    const prevTime = 0;
    const t = 5;
    let i = 5;

    let center = {};
    const requests = {
      "system": {
        "prompt": "You are a Virtual Companion called Meekaa, you should give short length human-like answers, your mission is to keep your user out of bad habits, pushing them into going to learn and stop doing useless things."
      },
      "emotions": {
        "prompt": "As a Virtual Companion, you have the capability of showing emotions/expresions, moving arround your eyes, and each part of your face individually, by typing them between brackets, these are your options: [eyes:happy/sad/neutral], [mouth:mappy/sad/neutral], [eyebrows:happy/sad/neutral], [lookX:(-1 - 1)], [lookY:(-1 - 1)]"
      },
      "reminder": {
        "prompt": "> Remind your host to have good habits. Choose randomly one of these examples or generate your own recomendation: to study, do exercise, eat healthy, dont stick to the computer all day, continue your back projects, do homework, and give some inapelable arguments."
      },
      "study": {
        "prompt": "> Make your host remember the things he has to learn divided in easy edible sections. This is the topic: "
      }
    }

    let reminders = {
      timer: -1,
      interval: 60*5,
      range: 60*5,
    }
    let brain = {
      startTime: Date.now(),
      currentEmotion: {},
      talking: true,
      blinkTimer: -1,
      conversation: [],
      
      chat: {
        fullText: '',
        text: '',
        charIndex: 0,
        typeSpeed: 80,
        lastCharTime: 0,
      }
    }


    let API_KEY = "";
    const API_URL = "https://api.groq.com/v1/llm/generate";

    fetch('/public/config.json')
      .then(res => res.json())
      .then(config => {
        console.log('API URL:', config.API_KEY);
        API_KEY = config.API_KEY;
    });

    async function getLLMResponse(prompt) {
        let promptChat = {
          role: "user",
          content: prompt
        }
        const response = await fetch("https://api.groq.com/openai/v1/responses", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${API_KEY}`
            },
            body: JSON.stringify({
                model: "openai/gpt-oss-20b",
                input: [
                  {
                    role: "system",
                    content: requests.system.prompt
                  },
                  {
                    role: "system",
                    content: requests.emotions.prompt
                  },
                  ...brain.conversation,
                  nextChat
                ]
            })
        });

        const data = await response.json();

        //console.log(data.output_text || data);

        const assistantMessages = data.output.filter( (msg) => msg.type === "message" );

        const textOutput = assistantMessages
          .map(msg => msg.content.map(c => c.text).join(" "))
          .join("\n");
        //console.log(output, data);

        brain.conversation.push(nextChat);
        assistantMessages.forEach((msg) => {
          brain.conversation.push(msg);
        })
        console.log(brain.conversation);

        chat(textOutput);

        return textOutput, data;
    }

    /*
    async function askLLM(prompt) {
      try {
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${API_KEY}`
          },
          body: JSON.stringify({
            model: "llama-3.3-70b-versatile", // Example model
            input: prompt
          })
        });

        const data = await response.json();
        return data.output || JSON.stringify(data, null, 2);
      } catch (error) {
        console.error("Error calling Groq API:", error);
        return "Error calling API. Check console.";
      }
    }

    async function testLLM() {
      const result = await askLLM('I want you to answer something');
      console.log(result);
    }

    testLLM(); // call the async function*/

    function resizeCanvas() {
      // Set the canvas resolution to match the *actual pixel size*
      
      const dpr = window.devicePixelRatio || 1;

      canvas.width = window.innerWidth * dpr/1;
      canvas.height = window.innerHeight * dpr/1;

      // Scale the context so drawing works in CSS pixels
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }

    function clear() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function snap (a, b, c, d) {
      //return [a, b, c, d];
      return [Math.floor(a), Math.floor(b), c?Math.floor(c):null, d?Math.floor(d):null];
    }
    function relativeToPixels(px, py, sx, sy) {
      const reference = canvas.width > canvas.height ? canvas.height : canvas.width;
      return [px*reference, py*reference, sx*reference, sy*reference];
    }
    function centered(px, py, sx, sy) {
      return [px+canvas.width/2-sx/2, py+canvas.height/2-sy/2, sx, sy];
    }
    function rel(x, y, a=null, b=null) {
      const reference = canvas.width > canvas.height ? canvas.height : canvas.width;
      return [x*reference + canvas.width/2, y*reference + canvas.height/2, a?a*reference:null]
    }

    function pather(path) {
      let action = 'm';
      path.list.forEach(e => {
        action = e.t || action;
        if (action=='m') {
          ctx.moveTo(...rel(path.offset.x + e.x*path.scale.x, path.offset.y + e.y*path.scale.y));
        } else if (action=='l') {
          ctx.lineTo(...rel(path.offset.x + e.x*path.scale.x, path.offset.y + e.y*path.scale.y));
        }
      });
      for (const key in path) {
        if (Object.hasOwn(path, key)) {
          delete path[key];
        }
      }
    }

    function drawMouth(type, pose) {
      ctx.lineWidth = .0;
      let px = 0;
      let py = .1;
      ctx.beginPath();

      if (type == 'smile') {
        if (pose == 'open') {
          pather({offset: {x:px,y:py}, scale:{x:1,y:1}, list:[
            {t:'m',x:-.05,y:-.02},
            {t:'l',x:.05,y:-.02},
            {t:'l',x:.03,y:.02},
            {t:'l',x:-.03,y:.02},
          ]});
        } else {
          pather({offset: {x:px,y:py}, scale:{x:1,y:1}, list:[
            {t:'m',x:-.02,y:-.01},
            {t:'l',x:.02,y:-.01},
            {t:'l',x:.01,y:.0},
            {t:'l',x:-.01,y:.0},
          ]});
        }
      } else if (type == 'sad') {
        if (pose == 'open') {
          pather({offset: {x:px,y:py}, scale:{x:1,y:1}, list:[
            {t:'m',x:-.05,y:.02},
            {t:'l',x:.05,y:.02},
            {t:'l',x:.03,y:-.02},
            {t:'l',x:-.03,y:-.02},
          ]});
        } else {
          pather({offset: {x:px,y:py}, scale:{x:1,y:1}, list:[
            {t:'m',x:-.02,y:.01},
            {t:'l',x:.02,y:.01},
            {t:'l',x:.0,y:.0},
          ]});
        }
      }
      if (['a','i'].findIndex(pose)) { // Ahh

      } else if (['b','m','p'].findIndex(pose)) { // Mmmm

      } else if (['c','d','z'].findIndex(pose)) { // Zzz

      } else if (['e'].findIndex(pose)) { // Ehh
      
      } else if (['f','v'].findIndex(pose)) { //Fff

      } else if (['g','h','j','k','q','t','x'].findIndex(pose)) { // Gkh

      } else if (['l','r'].findIndex(pose)) { // L

      } else if (['o','u'].findIndex(pose)) { // Ooohh

      } else if (['s','y'].findIndex(pose)) { // Sss

      }
      ctx.closePath();
      ctx.fill(); 
      ctx.stroke(); 
    }

    function drawEye(type, pose, s) {

      ctx.lineWidth = .0;
      let px = s*.2;
      let py = -.05;

      px += 0;
      py += 0;
      ctx.beginPath();

      if (type == 'neutral') {
        if (pose == 'closed') {
          pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
            {t:'m',x:-.12,y:.0},
            {t:'l',x:-.02,y:.01},
            {t:'l',x:.07,y:-.01},
            {t:'l',x:.14,y:-.05},
            {t:'l',x:.12,y:-.01},
            {t:'l',x:-.01,y:.04},
          ]});
          ctx.closePath();
          ctx.fill(); 
          ctx.stroke(); 
        } else {
          pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
            {t:'m',x:-.12,y:-.1},
            {t:'l',x:-.05,y:-.125},
            {t:'l',x:.09,y:-.04},
            {t:'l',x:.1,y:-.04},
            {t:'l',x:.16,y:-.05},
            {t:'l',x:.12,y:-.02},
            {t:'l',x:.06,y:.025},
            {t:'l',x:.04,y:.03},
            {t:'l',x:.09,y:-.02},
            {t:'l',x:-.08,y:-.1},
          ]});
          ctx.closePath();
          ctx.fill(); 
          ctx.stroke(); 
        }
      }
      pather({offset: {x:px+s*.04,y:py-.12}, scale:{x:s,y:1}, list:[
        {t:'m',x:-.08,y:-.09},
        {t:'l',x:-.04,y:-.1},
        {t:'l',x:.02,y:-.06},
        {t:'l',x:-.05,y:-.09},
      ]});
      ctx.closePath();
      ctx.fill(); 
      ctx.stroke(); 

      if (pose != 'closed') {
        px += -s*.085;
        py += -0.01;
        let pupil = 0.02;
        pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
          {t:'m',x:pupil,y:pupil},
          {t:'l',x:-pupil,y:pupil},
          {t:'l',x:-pupil,y:-pupil},
          {t:'l',x:pupil,y:-pupil},
        ]});
      }

      ctx.closePath();
      ctx.fill(); 
      ctx.stroke(); 
    }

    function animate() {
      let emote = {};

      ctx.fillStyle = 'lightgreen';
      ctx.strokeStyle = 'white';

      emote.talking = brain.talking;
      emote.eyes = 'neutral';
      emote.eyesPose = (brain.blinking==1 || brain.blinking==2) ? 'closed' : 'open';
      emote.mouth = 'smile';
      emote.mouthPose = (Math.floor(Date.now()/250)%2 == 0 || !emote.talking) ? 'closed' : 'open';

      var matches = brain.chat.fullText.match(/\[(.*?)\]/);
      matches.forEach((content) => {
        let obj, value = content.split(':');
        if (obj == 'mouth') {
          emote.mouth = value;
        }
      });
      drawMouth(emote.mouth, emote.mouthPose);
      
      drawEye(emote.eyes, emote.eyesPose, -1);
      drawEye(emote.eyes, emote.eyesPose, 1);

      brain.currentEmotion = emote;
    }

    function chat(text) {
      brain.talking = !brain.talking;
      if (brain.talking) {
        brain.chat.text = '';
        brain.chat.fullText = text;
        brain.chat.charIndex = 0;
        brain.chat.lastCharTime = brain.lastTime;
        input.innerHTML = brain.chat.text;
      }
    }

    let first = true;
    function render(currentTime) {
      i++;

      if (i >= t) {
        let deltaTime = currentTime - (brain.lastTime || currentTime);
        //console.log('Rendering ' + deltaTime);
        i -= t;

        if (brain.blinkTimer < currentTime) {
          if (brain.blinkTimer+300 < currentTime) {
            brain.blinkTimer += (Math.random()*7 + 1)*1000;
          } else if (brain.blinkTimer+150 < currentTime) {
            brain.blinking = 2;
          } else {
            brain.blinking = 1;
          }
        } else {
          brain.blinking = 0;
        }

        resizeCanvas();
        clear();
        animate();

        brain.lastTime = currentTime;
      }

      // --- Typing effect handled here ---
      if (brain.talking) {
        const chat = brain.chat;
        const timeSinceLastChar = currentTime - chat.lastCharTime;

        if (timeSinceLastChar >= chat.typeSpeed) {
            if (chat.charIndex < chat.fullText.length) {
            // Add next character to chat text
            chat.text += chat.fullText[chat.charIndex];
            chat.charIndex++;
            chat.lastCharTime = currentTime;
            input.innerHTML = brain.chat.text;

            if (chat.fullText[chat.charIndex] == ' ') { chat.lastCharTime += chat.typeSpeed*1; }
            if (chat.fullText[chat.charIndex] == ',') { chat.lastCharTime += chat.typeSpeed*4; }
            if (chat.fullText[chat.charIndex] == '.') { chat.lastCharTime += chat.typeSpeed*6; }
          } else {
            brain.talking = false;
          }
        }
      }

      //if ((currentTime - brain.chat.lastCharTime > 5000)) { chat('Owo, uwu'); }
      
      if (reminders.timer == -1) {
        reminders.timer = (Math.random()*reminders.range + reminders.interval)*1000;
      } else if (reminders.timer < currentTime) {
        reminders.timer += (Math.random()*reminders.range + reminders.interval)*1000;
        console.log('should say something now');
        //chat('IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII')
        let output, data = getLLMResponse(requests.reminder.prompt);
        typedText = '';
      }

      if (first) {
        first = !first;
        //chat('.......................................')
      }

      requestAnimationFrame(render);
    }

    let typedText = '';
    document.addEventListener('keydown', (event) => {
      const key = event.key;

      // Handle backspace
      if (key === 'Backspace') {
        typedText = typedText.slice(0, -1);
      }
      // Handle normal characters
      else if (key.length === 1) {
        typedText += key;
      }
      // Optionally handle Enter or Space
      else if (key === 'Enter') {
        let output, data = getLLMResponse(typedText);
        typedText = '';
        
      } else if (key === ' ') {
        typedText += ' ';
      }

      input.innerHTML = typedText; // Display current typed text
      console.log('Current typed text:', typedText); // Optional debug
    });

    requestAnimationFrame(render);
  </script>
</html>