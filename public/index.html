<!doctype html>
<html>
  <head>
    <title>Meekaa</title>

    <link rel="icon" href="./assets/meekaa.svg">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
      body {
        display: block;
        margin: 0px;
        overflow: hidden;
        width: 100%;
        height: 100%;
      }
      #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        image-rendering: pixelated;
      }
      #input {
        position: absolute;
        bottom: 0%;
        left: 5%;
        width: 90%;
        height: 15%;
        image-rendering: pixelated;
        text-align: center;
        font-size: 30px; 
        color: white;
      }
    </style>
  </head>
  
  <body>
    <div id="input">
      
    </div>
    <canvas id="canvas"></canvas>
    <canvas id="buffer" style="display: none;"></canvas>
  </body>
  
  <script>
    const input = document.getElementById("input");

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext('2d');
    const buffer = document.getElementById('buffer');
    buffer.width = 32;
    buffer.height = 32;
    const bctx = buffer.getContext('2d');

    const prevTime = 0;
    const t = 5;
    let i = 5;

    let DEBUG = false;

    let center = {};
    const requests = {
      "system": {
        "prompt": "You are a Virtual Companion called Meekaa, you should give short length human-like answers, your mission is to keep your user out of bad habits, pushing them into going to learn and stop doing useless things. You must answer as human-like wrote text without using any special marks aside from the needed ones."
      },
      "emotions": {
        "prompt": "As a Virtual Companion, you can and MUST show emotions/expresions, moving arround your eyes or and each part of your face individually to show yourself better for a human, by typing the expression between brackets. Change your expresion mid message using these brackets again to enhance it and make it feel more humanlike, these are your options: [eyes:happy/sad/neutral], [eyebrows:happy/sad/neutral], [lookX:(-1 - 1)], [lookY:(-1 - 1)]"
      },
      "reminder": {
        "prompt": "> Quickly remind your host to have good habits. Choose randomly one of these examples or generate your own recomendation: to study, do exercise, eat healthy, dont stick to the computer all day, continue your back projects, do homework, and give some inapelable arguments."
      },
      "study": {
        "prompt": "> Make your host remember the things he has to learn divided in easy edible sections. This is the topic: "
      }
    }

    let reminders = {
      timer: -1,
      interval: 60*5,
      range: 60*5,
    }
    let brain = {
      startTime: Date.now(),
      currentEmotion: {},
      emote: {},
      talking: false,
      blinkTimer: -1,
      conversation: [],
      
      chat: {
        fullText: '',
        text: '',
        charIndex: 0,
        typeSpeed: 80,
        lastCharTime: 0,
      }
    }


    let API_KEY = "";
    const API_URL = "https://api.groq.com/v1/llm/generate";

    fetch('/public/config.json')
      .then(res => res.json())
      .then(config => {
        console.log('API URL:', config.API_KEY);
        API_KEY = config.API_KEY;
    });

    async function getLLMResponse(prompt) {
      let promptChat = {
        role: "user",
        content: prompt
      }
      const response = await fetch("https://api.groq.com/openai/v1/responses", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${API_KEY}`
        },
        body: JSON.stringify({
          model: "openai/gpt-oss-120b",
          input: [
            {
              role: "system",
              content: requests.system.prompt
            },
            {
              role: "system",
              content: requests.emotions.prompt
            },
            ...brain.conversation,
            promptChat
          ]
        })
      });

      const data = await response.json();

      //console.log(data.output_text || data);

      const assistantMessages = data.output.filter( (msg) => msg.type === "message" );

      const textOutput = assistantMessages
        .map(msg => msg.content.map(c => c.text).join(" "))
        .join("\n");
      //console.log(output, data);

      brain.conversation.push(promptChat);
      assistantMessages.forEach((msg) => {
        brain.conversation.push(msg);
      })
      console.log(brain.conversation);

      chat(textOutput);

      return textOutput, data;
    }

    /*
    async function askLLM(prompt) {
      try {
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${API_KEY}`
          },
          body: JSON.stringify({
            model: "llama-3.3-70b-versatile", // Example model
            input: prompt
          })
        });

        const data = await response.json();
        return data.output || JSON.stringify(data, null, 2);
      } catch (error) {
        console.error("Error calling Groq API:", error);
        return "Error calling API. Check console.";
      }
    }

    async function testLLM() {
      const result = await askLLM('I want you to answer something');
      console.log(result);
    }

    testLLM(); // call the async function*/

    function resizeCanvas() {
      // Set the canvas resolution to match the *actual pixel size*
      
      const dpr = window.devicePixelRatio || 1;

      canvas.width = window.innerWidth * dpr/1;
      canvas.height = window.innerHeight * dpr/1;

      // Scale the context so drawing works in CSS pixels
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }

    function clear() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function snap (a, b, c, d) {
      //return [a, b, c, d];
      return [Math.floor(a), Math.floor(b), c?Math.floor(c):null, d?Math.floor(d):null];
    }
    function relativeToPixels(px, py, sx, sy) {
      const reference = canvas.width > canvas.height ? canvas.height : canvas.width;
      return [px*reference, py*reference, sx*reference, sy*reference];
    }
    function centered(px, py, sx, sy) {
      return [px+canvas.width/2-sx/2, py+canvas.height/2-sy/2, sx, sy];
    }
    function rel(x, y, a=null, b=null) {
      const reference = canvas.width > canvas.height ? canvas.height : canvas.width;
      return [x*reference + canvas.width/2, y*reference + canvas.height/2, a?a*reference:null]
    }

    function pather(path) {
      let action = 'm';
      path.list.forEach(e => {
        action = e.t || action;
        if (action=='m') {
          ctx.moveTo(...rel(path.offset.x + e.x*path.scale.x, path.offset.y + e.y*path.scale.y));
        } else if (action=='l') {
          ctx.lineTo(...rel(path.offset.x + e.x*path.scale.x, path.offset.y + e.y*path.scale.y));
        }
      });
      for (const key in path) {
        if (Object.hasOwn(path, key)) {
          delete path[key];
        }
      }
    }

    function drawMouth(type, pose) {
      ctx.lineWidth = .0;
      let px = 0;
      let py = .1;
      ctx.beginPath();

      let mouthList = [];
      if (['a','i'].includes(pose)) { // Ahh
        mouthList = [
          {t:'m',x:-.05,y:-.02},
          {t:'l',x:.05,y:-.02},
          {t:'l',x:.03,y:.02},
          {t:'l',x:-.03,y:.02},
        ];
      } else if (['b','m','p'].includes(pose)) { // Mmmm
        mouthList = [
          {t:'m',x:-.06,y:-.01},
          {t:'l',x:.06,y:-.01},
          {t:'l',x:.04,y:.0},
          {t:'l',x:-.04,y:.0},
        ];
      } else if (['c','d','z'].includes(pose)) { // Zzz
        mouthList = [
          {t:'m',x:-.06,y:-.02},
          {t:'l',x:.06,y:-.02},
          {t:'l',x:.0,y:.0},
        ];
      } else if (['e','g','h','j','k','q'].includes(pose)) { // Ehh
        mouthList = [
          {t:'m',x:-.05,y:-.01},
          {t:'l',x:.05,y:-.01},
          {t:'l',x:.03,y:.02},
          {t:'l',x:-.03,y:.02},
        ];
      } else if (['f','v'].includes(pose)) { //Fff
        mouthList = [
          {t:'m',x:-.06,y:-.01},
          {t:'l',x:.06,y:-.01},
          {t:'l',x:.04,y:.0},
          {t:'l',x:.0,y:-.01},
          {t:'l',x:-.04,y:.0},
        ];
      } else if (['l','r'].includes(pose)) { // L
        mouthList = [
          {t:'m',x:-.03,y:-.02},
          {t:'l',x:.03,y:-.02},
          {t:'l',x:.03,y:.02},
          {t:'l',x:-.03,y:.02},
        ];
      } else if (['o','u'].includes(pose)) { // Ooohh
        mouthList = [
          {t:'m',x:-.04,y:-.03},
          {t:'l',x:.04,y:-.03},
          {t:'l',x:.04,y:.03},
          {t:'l',x:-.04,y:.03},
        ];
      } else if (['n','s','t','x','y'].includes(pose)) { // Sss
        mouthList = [
          {t:'m',x:-.04,y:-.02},
          {t:'l',x:.04,y:-.02},
          {t:'l',x:.04,y:.01},
          {t:'l',x:-.04,y:.01},
        ];
      } else {
        mouthList = [
          {t:'m',x:-.04,y:-.01},
          {t:'l',x:.04,y:-.01},
          {t:'l',x:.02,y:.0},
          {t:'l',x:-.02,y:.0},
        ];
      }

      pather({offset: {x:px,y:py}, scale:{x:1,y:1}, list:mouthList});
      ctx.closePath();
      ctx.fill(); 
      ctx.stroke(); 
    }

    function drawEye(type, pose, s) {

      ctx.lineWidth = .0;
      let px = s*.2;
      let py = -.05;

      px += 0;
      py += 0;
      ctx.beginPath();

      if (type == 'neutral') {
        if (pose == 'closed') {
          pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
            {t:'m',x:-.12,y:.0},
            {t:'l',x:-.02,y:.01},
            {t:'l',x:.07,y:-.01},
            {t:'l',x:.14,y:-.05},
            {t:'l',x:.12,y:-.01},
            {t:'l',x:-.01,y:.04},
          ]});
          ctx.closePath();
          ctx.fill(); 
          ctx.stroke(); 
        } else {
          pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
            {t:'m',x:-.12,y:-.1},
            {t:'l',x:-.05,y:-.125},
            {t:'l',x:.09,y:-.04},
            {t:'l',x:.1,y:-.04},
            {t:'l',x:.16,y:-.05},
            {t:'l',x:.12,y:-.02},
            {t:'l',x:.06,y:.025},
            {t:'l',x:.04,y:.03},
            {t:'l',x:.09,y:-.02},
            {t:'l',x:-.08,y:-.1},
          ]});
          ctx.closePath();
          ctx.fill(); 
          ctx.stroke(); 
        }
      }
      if (type == 'happy') {
        if (pose == 'closed') {
          pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
            {t:'m',x:-.12,y:.0},
            {t:'l',x:-.02,y:.01},
            {t:'l',x:.07,y:-.01},
            {t:'l',x:.14,y:-.05},
            {t:'l',x:.12,y:-.01},
            {t:'l',x:-.01,y:.04},
          ]});
          ctx.closePath();
          ctx.fill(); 
          ctx.stroke(); 
        } else {
          pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
            {t:'m',x:-.12,y:-.12},
            {t:'l',x:-.05,y:-.145},
            {t:'l',x:.09,y:-.042},
            {t:'l',x:.1,y:-.042},
            {t:'l',x:.16,y:-.05},
            {t:'l',x:.12,y:-.02},
            {t:'l',x:.06,y:.025},
            {t:'l',x:.04,y:.03},
            {t:'l',x:.09,y:-.02},
            {t:'l',x:-.05,y:-.11},
          ]});
          ctx.closePath();
          ctx.fill(); 
          ctx.stroke(); 
        }
      }




      pather({offset: {x:px+s*.04,y:py-.12}, scale:{x:s,y:1}, list:[
        {t:'m',x:-.08,y:-.09},
        {t:'l',x:-.04,y:-.1},
        {t:'l',x:.02,y:-.06},
        {t:'l',x:-.05,y:-.09},
      ]});
      ctx.closePath();
      ctx.fill(); 
      ctx.stroke(); 

      if (pose != 'closed') {
        px += -s*.085;
        py += -0.01;
        let pupil = 0.02;
        pather({offset: {x:px,y:py}, scale:{x:s,y:1}, list:[
          {t:'m',x:pupil,y:pupil},
          {t:'l',x:-pupil,y:pupil},
          {t:'l',x:-pupil,y:-pupil},
          {t:'l',x:pupil,y:-pupil},
        ]});
        ctx.closePath();
        ctx.fill(); 
        ctx.stroke(); 
      }
    }

    function animate() {

      ctx.fillStyle = 'lime';
      ctx.strokeStyle = 'white';

      brain.emote.talking = brain.talking;
      brain.emote.eyes = brain.emote.eyes || brain.currentEmotion.eyes || 'neutral';
      brain.emote.eyesPose = (brain.blinking==1 || brain.blinking==2) ? 'closed' : 'open';

      brain.emote.mouth = 'neutral';
      brain.emote.mouthPose = (brain.emote.talking) ? ((Math.floor(Date.now()/250)%2 == 0) ? 'b' : 'a') : ' ';

      drawMouth(brain.emote.mouth, brain.emote.mouthPose);
      
      drawEye(brain.emote.eyes, brain.emote.eyesPose, -1);
      drawEye(brain.emote.eyes, brain.emote.eyesPose, 1);

      //console.log(brain.emote.eyes);

      brain.currentEmotion = brain.emote;
      brain.emote = {};
    }

    function chat(text) {
      brain.talking = !brain.talking;
      if (brain.talking) {
        brain.chat.text = '';
        brain.chat.fullText = text;
        brain.chat.charIndex = 0;
        brain.chat.lastCharTime = brain.lastTime;
        input.innerHTML = brain.chat.text;
      }
    }

    let first = true;
    function render(currentTime) {
      i++;

      if (i >= t) {
        let deltaTime = currentTime - (brain.lastTime || currentTime);
        //console.log('Rendering ' + deltaTime);
        i -= t;

        if (brain.blinkTimer < currentTime) {
          if (brain.blinkTimer+300 < currentTime) {
            brain.blinkTimer += (Math.random()*7 + 1)*1000;
          } else if (brain.blinkTimer+150 < currentTime) {
            brain.blinking = 2;
          } else {
            brain.blinking = 1;
          }
        } else {
          brain.blinking = 0;
        }

        resizeCanvas();
        clear();
        animate();

        brain.lastTime = currentTime;
      }

      // --- Typing effect handled here ---
      if (brain.talking) {
        const chat = brain.chat;
        const timeSinceLastChar = currentTime - chat.lastCharTime;

        if (timeSinceLastChar >= chat.typeSpeed) {
          if (chat.charIndex < chat.fullText.length) {
            let nextChar = chat.fullText[chat.charIndex];

            // --- Detect emotion trigger inside brackets ---
            if (nextChar === '[') {
              // Find the closing bracket
              const closeIndex = chat.fullText.indexOf(']', chat.charIndex);
              if (closeIndex !== -1) {
                // Extract emotion keyword
                const emotion = chat.fullText.substring(chat.charIndex + 1, closeIndex);
                // Run your emotion handler function
                if (emotion.trim()) {
                  let pose = emotion.trim().split(':');
                  //console.log(pose);
                  brain.emote[pose[0]] = pose[1];
                  //setEmotion(emotion.trim());
                }
                // Skip past the entire [emotion]
                if (DEBUG) {
                  chat.text += nextChar;
                  chat.charIndex++;
                } else {
                  chat.charIndex = closeIndex + 1;
                }

              } else {
                chat.text += nextChar;
                chat.charIndex++;
              }
            } else {
              chat.text += nextChar;
              chat.charIndex++;
            }

            // --- Add next character to displayed text ---
            chat.lastCharTime = currentTime;
            input.innerHTML = chat.text;

            // --- Punctuation delays ---
            if (nextChar === ' ') chat.lastCharTime += chat.typeSpeed * 0.5;
            if (nextChar === ',') chat.lastCharTime += chat.typeSpeed * 4;
            if (nextChar === '.') chat.lastCharTime += chat.typeSpeed * 6;
          } else {
            brain.talking = false;
          }
        }
      }

      //if ((currentTime - brain.chat.lastCharTime > 5000)) { chat('Owo, uwu'); }
      
      if (reminders.timer == -1) {
        reminders.timer = (Math.random()*reminders.range + reminders.interval)*10;
      } else if (reminders.timer < currentTime) {
        reminders.timer += (Math.random()*reminders.range + reminders.interval)*1000;
        console.log('should say something now');
        //chat('IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII')
        let output, data = getLLMResponse(requests.reminder.prompt);
        typedText = '';
      }

      if (first) {
        first = !first;
        //chat('[eyes:happy][eyebrows:happy]Hello my dear[eyes:neutral][eyebrows:neutral], how was your day?')
      }

      requestAnimationFrame(render);
    }

    let typedText = '';
    document.addEventListener('keydown', (event) => {
      const key = event.key;

      // Handle backspace
      if (key === 'Backspace') {
        typedText = typedText.slice(0, -1);
      }
      // Handle normal characters
      else if (key.length === 1) {
        typedText += key;
      }
      // Optionally handle Enter or Space
      else if (key === 'Enter') {
        let output, data = getLLMResponse(typedText);
        typedText = '';
        
      } else if (key === ' ') {
        typedText += ' ';
      }

      input.innerHTML = typedText; // Display current typed text
      console.log('Current typed text:', typedText); // Optional debug
    });

    requestAnimationFrame(render);
  </script>
</html>